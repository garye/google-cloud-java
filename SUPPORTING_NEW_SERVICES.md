## Supporting New Services

### Overview

This document outlines how to add support for a new service in `google-cloud`.  New services should be submodules located in a folder within the main repository, built using Maven.  A new service should contain the following items:

* An API layer, with which users will interact.  This includes model objects and a service class. 
* An SPI layer, which translates google-cloud API calls into RPCs using an autogenerated client library.  In almost all use cases, the user will not directly interact with this code.  Separating this code from the API layer provides two benefits.  First, it allows the API layer to remain stable despite changes to the autogenerated libraries used.  Second, it makes testing easier, since the RPC implementation can be substituted with a mock.
* A test helper class, which allows users to easily interact with a local service emulator (if possible).  If there is no emulator available and the service is too complex to create a mock, then a remote test helper should be provided to separate test data from other user data and enable easy cleanup.
* Tests, including unit tests and integration tests.
* A command line example application.
* Documentation, which is comprised of READMEs, Javadoc, and code snippets.

### Components of a new service

#### API layer

Before starting work on the API layer, write a design document and provide sample API code.  Sample API code should either be included in the design document or as a pull request tagged with the "don't merge" label.  As part of the design process, be sure to examine the Google Cloud service API and any implementations provided in other gcloud-* language libraries.  Solicit feedback from other contributors to the repository.  `google-cloud` services should be low-level while minimizing boilerplate code needed by API users.  They should also be flexible enough to be used by higher-level libraries.  For example, [Objectify](https://github.com/objectify/objectify) should be able to use `google-cloud-datastore`.

The library should contain:
* A subclass of the [`ServiceOptions`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-core/src/main/java/com/google/cloud/ServiceOptions.java) class. The `ServiceOptions` class contains important information for communicating with the Google Cloud service, such as the project ID, authentication, and retry handling.  Subclasses should add/override relevant methods as necessary.  Example: [`DatastoreOptions`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-datastore/src/main/java/com/google/cloud/datastore/DatastoreOptions.java).
* An interface extending the [`Service`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-core/src/main/java/com/google/cloud/Service.java) interface (example: [`Datastore`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-datastore/src/main/java/com/google/cloud/datastore/Datastore.java)) and an implementation of that interface (example: [`DatastoreImpl`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-datastore/src/main/java/com/google/cloud/datastore/DatastoreImpl.java)).
* An interface extending the [`ServiceFactory`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-core/src/main/java/com/google/cloud/ServiceFactory.java) interface.  Example: [`DatastoreFactory`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-datastore/src/main/java/com/google/cloud/datastore/DatastoreFactory.java)
* A runtime exception class that extends [`BaseServiceException`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-core/src/main/java/com/google/cloud/BaseServiceException.java), which is used to wrap service-related exceptions.  Example: [`DatastoreException`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-datastore/src/main/java/com/google/cloud/datastore/DatastoreException.java)
* Classes representing model objects and request-related options.  Model objects that correspond to service resources should have a subclass that provides functions related to that resource.  For example, see [`BlobInfo`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-storage/src/main/java/com/google/cloud/storage/BlobInfo.java) (the metadata class) and [`Blob`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-storage/src/main/java/com/google/cloud/storage/Blob.java) (the functional class).  The builders for both objects should implement a common interface or abstract class, and the functional subclass builder should delegate to the metadata class builder.
* Request-related options classes.  Operations should accept these options as varargs when appropriate.  Supplying options as varargs allows for supporting more advanced use cases without affecting the method signature.  The options classes should provide static methods to create instances with specific options settings.  A common option is to request that only specific fields of a model object should be included in a response.  Typically such an option is created via a `fields(...)` method which accepts a vararg of type `<ResourceName>Field` enum.  The enum should implement the [FieldSelector](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-core/src/main/java/com/google/cloud/FieldSelector.java) interface.

In general, make classes immutable whenever possible, providing builders as necessary.  Make model object classes `java.util.Serializable`.  Prefer making classes final, with the following exceptions: (1) functional objects and (2) classes in which the user cannot set all attributes.  If a class cannot be made final, then `hashCode` or `equals` overrides should be made final if possible.

`google-cloud-core` provides functionality for code patterns used across `google-cloud` libraries.  The following are some important core concepts:
* Paging: Google Cloud services often expose page-based listing using page tokens.  The [`Page`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-core/src/main/java/com/google/cloud/Page.java) interface should be used for page-based listing.  A `Page` contains an iterator over results in that page, as well as methods to get the next page and all results in future pages.  `Page` requires a `NextPageFetcher` implementation (see the `NextPageFetcher` interface in [`PageImpl`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-core/src/main/java/com/google/cloud/PageImpl.java)).  This implementation should delegate constructing request options to the `nextRequestOptions` method in `PageImpl`.

* Exception handling: we have the notion of retryable versus non-retryable operations.  These are encapsulated by `BaseServiceException`.  Retryable error codes should be listed in the service's subclass of `BaseServiceException`.  An operation should be considered retryable if it makes sense to retry (e.g. if there was a transient service error, not a fundamentally invalid request) and if the operation that triggered the exception is idempotent.  Exceptions also contain information regarding whether the service rejected the request, meaning the operation was not applied.  The `BaseServiceException` subclass should also provide methods to translate the exceptions given by the underlying autogeneraged client library.  The [`ExceptionHandler`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-core/src/main/java/com/google/cloud/ExceptionHandler.java) class intercepts and retries RPC calls when retryable exceptions are encountered.  Note that some exceptions are masked in the SPI layer.  For example, `get` and `delete` operations often return "404 Not Found" if the resource doesn't exist.  Instead of throwing an exception in these cases, we often return `null` for `get` and `false` for `delete`.

* Batching: The [`BatchResult`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/dns-alpha-batch/google-cloud-core/src/main/java/com/google/cloud/BatchResult.java) class provides a simple way for users to combine RPC calls for performance enhancement.  APIs for services that support batching should implement a batch class that contains methods similar to the methods in the `Service.java` subclass.  A batch operation's return type should be a subclass of `BatchResult`.  Also provide an SPI-layer class to collect batch requests and submit the batch.  A batch instance should be created by the service API, preferably via a method called `batch()`.  The batch should be submitted using the batch instance itself, preferably using a method named `submit()`.

* IAM Policies: If the Google Cloud service supports [IAM](https://cloud.google.com/iam/docs/), you should provide a subclass of [`IamPolicy`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-core/src/main/java/com/google/cloud/IamPolicy.java) in your API.  [`Policy`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-resourcemanager/src/main/java/com/google/cloud/resourcemanager/Policy.java) can be used to set default access control lists on Google Cloud projects as a whole.  However, if users want to set policies on specific resources within a project, they will need to use the subclass you provide in your API.

Notes/reminders:
* API layer classes should be located in the package `com.google.cloud.servicename`, where "servicename" corresponds to the name of the Google Cloud service.
* Override the `ServiceOptions.defaultRetryParams()` method in your service's options class to align with the Service Level Agreement (SLA) given by the underlying service.  See #857 and #860 for context.
* Override the `ServiceOptions.projectIdRequired()` method to return false when the service does not require requests to be associated with a specific project.
* See conventions about overriding the `equals` and `hashCode` methods in the discussion of #892.
* While not all fields for model objects need to be exposed to the user, `google-cloud` services should get and set all relevant fields when making RPC calls to the Google Cloud service's API.  For example, since the `parent` field of Cloud Resource Manager Project objects is in alpha (at the time this was written) and not available to most users, `google-cloud-resourcemanager` gets and sets the parent when interacting with the Cloud Resource Manager, but does not expose the parent to users.  As a result, the user won't accidentally unset the parent when updating a project.
* Be aware of differences in "update" behavior and name update/replace methods accordingly in your API.  See #321 for context.
* Do not expose third party libraries in the API.  This has been a design choice from the beginning of the project, and all existing `google-cloud` services adhere to this convention.
* Member variable getters and builder setters should not use the JavaBean get/set prefix style.
* Any service-generated IDs for model objects should be named `generatedId()`.

#### SPI layer

The SPI layer classes should be located in the package `com.google.cloud.servicename.spi`.  In most cases, the SPI layer should contain at least three classes:
* An RPC factory interface (allows for the implementation to be loaded via the `java.util.ServiceLoader`).
* An RPC interface that contains all RPC methods.
* A default RPC implementation.

#### Test helpers

Test helper classes should be located in the package `com.google.cloud.servicename.testing`.  The naming convention for test helpers is `[Local|Remote][Service]Helper.java`.  For example, the local test helper for `google-cloud-datastore` is named `LocalDatastoreHelper` and the remote test helper for `google-cloud-storage` is named `RemoteStorageHelper`.  All test helpers should contain public `create` and `options` methods, and local helpers should contain `start` and `stop` methods.  See existing test helpers for information on what each of those methods should do.

There are three types of test helpers:
* When a local emulator is already available, your test helper should launch that emulator and return service options to connect to that local emulator.  This enables both users and our own library to run unit tests easily.  An example of this type of helper is `LocalDatastoreHelper`.  Google Cloud Datastore provides a script that launches a local datastore, so `LocalDatastoreHelper` launches that script in a separate process when the user calls `start()`.

* When there is no local emulator but the service is simple enough to write an emulator, you should do so.  The emulator should listen to a port for requests, process those requests, and send responses back, being as true to the actual service as possible.  Dependencies in this mock should be as lightweight as possible.  Be sure to document differences between your emulator and the actual service.  Examples of this type of test helper are `LocalResourceManagerHelper` and `LocalDnsHelper`.

* When there is no local emulator and the service is too complex to write a solid emulator, the test helper should contain methods to get options and to help isolate test data from production data.  `RemoteStorageHelper` is an example of this type of test helper, since there is no local emulator for Google Cloud Storage (at the time that this was written) and because the Google Cloud Storage API is complex.  `RemoteStorageHelper` has methods to:
  * Get service options settings.
  * Create a test bucket with a sufficiently obscure name (to separate the bucket from any of the users other data).
  * Clean up data left over from tests in that test bucket.

#### Tests

API-level functionality should be well-covered by unit tests.  Coders and reviewers should examine test coverage to ensure that important code paths are not being left untested.  As of now, `google-cloud` relies on integration tests to test the SPI layer.  Unit tests for the API layer should be located in the package `com.google.cloud.servicename`.  Integration tests should be placed in a separate package, `com.google.cloud.servicename.it`, which enables us to catch method access bugs.  Unit tests for the test helper should be placed in the package `com.google.cloud.servicename.testing`.  All unit tests run for pull requests, but integration tests are only run upon merging the pull request.  We only run integration tests upon merging pull requests to avoid decrypting and exposing credentials to anybody who can create a pull request from a fork.  Prefix integration test file names with "IT" (e.g. `ITDnsTest`) to separate them from regular unit tests.

Simple service-related tests should be added to [GoogleCloudPlatform/google-cloud-examples](https://github.com/GoogleCloudPlatform/google-cloud-examples/tree/master/test-apps).  To test releases and platform-specific bugs, it's valuable to deploy the apps in that repository on App Engine, Compute Engine, and from your own desktop.

#### Example application

The example application should be a simple command line interface for the service.  It should use common library usage patterns so that users can have good examples of how to use the service.  Be sure to keep the examples up to date if/when there are updates that make the API cleaner and more concise.  See examples of applications under the `google-cloud-examples` folder.  The example application should be in the package `com.google.cloud.examples.servicename`.

#### Documentation

* Include a summary of the service and code snippets on the main repository's README.  These snippets should be simple and cover a few common usage patterns.  The README snippets should also be added to `google-cloud-examples` in the package `com.google.cloud.examples.servicename.snippets`.  Placing snippet code in the repository ensures that the snippet code builds when Travis CI is run.  For this purpose, README snippets and the snippet code in `google-cloud-examples` should be kept in sync.  Issue #753 suggests autogenerating READMEs, which would be useful for keeping snippet code in sync.  As of yet, we do not have unit tests for snippets, so the snippets should be tested periodically, especially after any relevant library updates.
* Create a README in the service's folder.  This README should mimic the structure of other services' READMEs.  In particular, you should create a step-by-step "Getting Started" guide.  See [`google-cloud-datastore`'s README](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-datastore/README.md) for reference.  All code in that step-by-step guide should also be included in the `google-cloud-examples` snippets package.
* The API and test helper packages should have `package-info.java` files.  These files should contain descriptions of the packages as well as simple example code and/or links to code snippets.
* Public methods, classes, and builders should contain meaningful Javadoc.  When possible, copy docs from the service's `cloud.google.com` API documentation and provide `@see` links to relevant Google Cloud web pages.  Document both unchecked and checked exceptions.
* Update [`TESTING`](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/TESTING.md) with how to run tests using the test helper.
* Update the [`google-cloud-examples` README](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-examples/README.md) with instructions on how to run your example application.

Notes/reminders:
* Clearly document which APIs must be enabled in the Developers Console's API Manager.
* Versioning in documentation is automatically updated by the script `utilities/update_docs_version.sh`.  Be sure to examine that script to make sure any version-dependent documentation will be updated properly upon release.

### Workflow

New services should be created in a branch based on `master`.  The branch name should include the suffix "-alpha".  For example, while developing `google-cloud-pubsub`, all Pub/Sub related work should be done in `pubsub-alpha`.  All code should be submitted through pull requests from a branch on a forked repository.  Limiting pull request size is very helpful for reviewers.  All code that is merged into the branch should be standalone and well-tested.  Any todo comments in the code should have an associated Github issue number for tracking purposes.  You should periodically pull updates from the master branch, especially if there are project-wide updates or if relevant changes have been made to the core utilities library, `google-cloud-core`.  This PR should only contain commits related to the merge to ease code review.

Create at least two milestones (stable and future) for your service and an issue tag with the service name.  Create issues for any to-do items and tag them appropriately.  This keeps an up-to-date short-term to-do list and also allows for longer term roadmaps.

Be sure you've configured the base folder's `pom.xml` correctly.
  * Add your module to the base directory's `pom.xml` file under the list of modules (in alphabetical order).
  * Add your module to the javadoc packaging settings.  See PR #802 for an example.

<!-- TODO: uncomment when gcs-nio branch is merged into master
  * Add your example to the assembler plugin.  PR #839 includes examples of using appassembler. -->

When your service is complete, contact the service owners to get a review.  The primary purpose of this review is to make sure that the google-cloud service interacts with the Google Cloud service properly.  Present the reviewers with a link to the Github repository, as well as your (updated) design document that details the API.

### Closing remarks

* Efforts should be made to maintain the current style of the repository and a consistent style between google-cloud services.
  * We anticipate that people will sometimes use multiple `google-cloud` services, so we don't want differences in conventions from one service API to another.  Look at existing `google-cloud` services to see coding and naming conventions.
  * Codacy is configured to report on pull requests about style issues.  Whenever possible, those comments should be addressed.  Coders and reviewers should also run a linter on pull requests, because the Codacy tool may not catch all style errors.  There is a [Checkstyle configuration](https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/checkstyle.xml) provided in the repository.
* When weighing which services to add, consider that a hand-crafted `google-cloud` service API is especially useful if it can simplify the usability of the autogenerated client.
